Time complexity analysis: computePath
V = amount of vertices
E = amount of edges

The time complexity of clear in priorityQueue is proportional to the amount of elements it contains (V elements) since
clear goes through every element in priorityQueue and sets the element to null. This gives O(V). The poll method removes
an element and has to sort the priorityQueue by bubbling and therefore has the time complexity O(log(V)). In the foreach
edge loop worst case scenario is that the vertex is connected to every other vertex and thus has a time complexity of
O(E) (E edges). // TODO: fixa


public void computePath(E from, E to) {
    pq.clear();                                                     //  O(V)
    visited.clear();                                                //  O(V)
    distances.clear();                                              //  O(V)
    previous.clear();                                               //  O(V)

    destination = g.getVertex(to);                                  //  O(1)
    Vertex<E> origin = g.getVertex(from);                           //  O(1)

    if (from.equals(to)) {                                          //  O(1)
        path.add(from);                                             //  O(1)
        distances.put(destination, 0);                              //  O(1)
        return;
    }

    for (Vertex<E> v : g.getVertices().values()) {                  //  O(V)
        distances.put(v, Integer.MAX_VALUE);                            //  O(1)
        previous.put(v, null);                                          //  O(1)
    }

    distances.put(origin, 0);                                       //  O(1)
    pq.add(origin);                                                 //  O(1)

    while (!pq.isEmpty()) {                                         //  O(V)
        Vertex<E> u = pq.poll();                                        //  O(log(V))
        if (!visited.contains(u)){                                      //  max O(V)
            for (Edge<E> e : g.getOutgoingEdges(u)) {                   //  O(E)
                Vertex<E> v = e.getHead();                                  //  O(1)
                int alt = distances.get(u) + e.getCost();                   //  O(1)
                if (alt < distances.get(v)) {                               //  O(1)
                    distances.put(v, alt);                                  //  O(1)
                    previous.put(v, u);                                     //  O(1)
                    pq.add(v);                                              //  O(log(V^2)) -> O(log(E))
                }
            }
            visited.add(u);                                             //  O(1)
        }
    }
}

For the upper part of the method, above the while loop, the complexity is O(V).
