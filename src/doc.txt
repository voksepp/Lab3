Time complexity analysis: computePath
V = amount of vertices
E = amount of edges

The time complexity of clear in priorityQueue is proportional to the amount of elements it contains (V elements) since
clear goes through every element in priorityQueue and sets the element to null. This gives O(V). The poll method removes
an element and has to sort the priorityQueue by bubbling and therefore has the time complexity O(log(V)). In the foreach
edge loop worst case scenario is that the vertex is connected to every other vertex and thus has a time complexity of
O(E) (E edges).

All operations in the outer level code: O(1) and O(V) -> O(V) dominant.
First loop level: O(log(V)) and O(E) -> O(E) dominant.
Second loop level: O(log(V))

->>> O(V) + O(E) * O(log(V))

In total the time complexity of the computePath method is O(V+E*log(V)). ??????

    public void computePath(E from, E to) {
        pq.clear();                                                     //  O(V)
        visited.clear();                                                //  O(V)
        distances.clear();                                              //  O(V)
        previous.clear();                                               //  O(V)

        destination = g.getVertex(to);                                  //  O(1)
        Vertex<E> origin = g.getVertex(from);                           //  O(1)

        if (from.equals(to)) {                                          //  O(1)
            path.add(from);                                             //  O(1)
            distances.put(destination, 0);                              //  O(1)
            return;
        }

        for (Vertex<E> v : g.getVertices().values()) {                  //  O(V)
            distances.put(v, Integer.MAX_VALUE);                            //  O(1)
            previous.put(v, null);                                          //  O(1)
        }

        distances.put(origin, 0);                                       //  O(1)
        pq.add(origin);                                                 //  O(1)
        visited.add(origin);                                            //  O(1)

        while (!pq.isEmpty()) {                                         //  O(V)
            Vertex<E> u = pq.poll();                                        //  O(log(V))
            for (Edge<E> e : g.getOutgoingEdges(u)) {                       //  O(E)
                Vertex<E> v = e.getHead();                                      //  O(1)
                int alt = distances.get(u) + e.getCost();                       //  O(1)
                if (alt < distances.get(v)) {                                   //  O(1)
                    distances.put(v, alt);                                      //  O(1)
                    previous.put(v, u);                                         //  O(1)
                    if (!visited.contains(v)) {                                 //  O(1)
                        pq.add(v);                                              //  O(log(V))
                        visited.add(v);                                         //  O(1)
                    }
                }
            }
        }

        Vertex<E> u = destination;                                      //  O(1)
        while (previous.get(u) != null) {                               //  O(V)
            path.add(u.getData());                                          // O(1)
            u = previous.get(u);                                            // O(1)
        }
        path.add(origin.getData());                                     //  O(1)
        Collections.reverse(path);                                      //  O(V)
    }