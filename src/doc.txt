Time complexity analysis: computePath
V = amount of vertices
E = amount of edges

public void computePath(E from, E to) {
    pq.clear();                                                     //  O(V)
    visited.clear();                                                //  O(V)
    distances.clear();                                              //  O(V)
    previous.clear();                                               //  O(V)

    destination = g.getVertex(to);                                  //  O(1)
    Vertex<E> origin = g.getVertex(from);                           //  O(1)

    if (from.equals(to)) {                                          //  O(1)
        path.add(from);                                             //  O(1)
        distances.put(destination, 0);                              //  O(1)
        return;
    }

    for (Vertex<E> v : g.getVertices().values()) {                  //  O(V)
        distances.put(v, Integer.MAX_VALUE);                            //  O(1)
        previous.put(v, null);                                          //  O(1)
    }

    distances.put(origin, 0);                                       //  O(1)
    pq.add(origin);                                                 //  O(1)

    while (!pq.isEmpty()) {                                         //  O((V^2)) -> O(E)
        Vertex<E> u = pq.poll();                                        //  O(log(E))
        if (!visited.contains(u)){                                      //  O(1), iterates V times
            for (Edge<E> e : g.getOutgoingEdges(u)) {                   //  O(V)
                Vertex<E> v = e.getHead();                                  //  O(1)
                int alt = distances.get(u) + e.getCost();                   //  O(1)
                if (alt < distances.get(v)) {                               //  O(1)
                    distances.put(v, alt);                                  //  O(1)
                    previous.put(v, u);                                     //  O(1)
                    pq.add(v);                                              //  O(log(V^2)) -> O(2log(V)) -> O(log(V))
                }
            }
            visited.add(u);                                             //  O(1)
        }
    }
}

For the upper part of the method, above the while loop, the complexity is O(V).

The inner for loop iterates in total once for every vertex in the graph -> V times -> complexity O(V*log(V)).

The while loop enclosing it runs once for every element in the queue -> at worst V^2 times -> O(E).

This leads to a total time complexity of O(V+E*log(V)).